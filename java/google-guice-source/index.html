<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="山间草夫的小站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="山间草夫的小站 Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/spring/rss.xml" title="山间草夫的小站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/spring/atom.xml" title="山间草夫的小站 Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/java/rss.xml" title="山间草夫的小站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/java/atom.xml" title="山间草夫的小站 Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/database/rss.xml" title="山间草夫的小站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/database/atom.xml" title="山间草夫的小站 Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/microservice/rss.xml" title="山间草夫的小站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/microservice/atom.xml" title="山间草夫的小站 Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/data-structure-and-algorithm/rss.xml" title="山间草夫的小站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/data-structure-and-algorithm/atom.xml" title="山间草夫的小站 Atom Feed">
<link rel="alternate" type="application/rss+xml" href="/devops/rss.xml" title="山间草夫的小站 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/devops/atom.xml" title="山间草夫的小站 Atom Feed"><title data-react-helmet="true">google guice 框架源码学习 | 山间草夫的小站</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://shanjiancaofu.com/java/google-guice-source"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="google guice 框架源码学习 | 山间草夫的小站"><meta data-react-helmet="true" name="description" content="1. Google Guice 框架简介"><meta data-react-helmet="true" property="og:description" content="1. Google Guice 框架简介"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2022-04-16T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://shanjiancaofu.com"><meta data-react-helmet="true" property="article:tag" content="java,DI,IOC"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://shanjiancaofu.com/java/google-guice-source"><link data-react-helmet="true" rel="alternate" href="https://shanjiancaofu.com/java/google-guice-source" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://shanjiancaofu.com/java/google-guice-source" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.7ec3e632.css">
<link rel="preload" href="/assets/js/runtime~main.e077049a.js" as="script">
<link rel="preload" href="/assets/js/main.b2bb5637.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/avtor.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/avtor.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">山间草夫</b></a><a class="navbar__item navbar__link" href="/docs/intro">Spring Boot中文文档</a><a class="navbar__item navbar__link" href="/docs/cli">API</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/java">Java</a><a class="navbar__item navbar__link" href="/microservice">Microservice</a><a class="navbar__item navbar__link" href="/database">Database</a><a class="navbar__item navbar__link" href="/devops">Devops</a><a class="navbar__item navbar__link" href="/data-structure-and-algorithm">数据结构与算法</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/jeesk" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a aria-current="page" class="sidebarItemLink_miNk sidebarItemLinkActive_RRTD" href="/java/google-guice-source">google guice 框架源码学习</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/java/java 源码分析">java 源码分析</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/java/elasticsearch-user-rtb-ad">Elasticsearch 在竞价广告中的检索使用</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/java/java-bio-diffrent-from-nio">Java BiO和NIO的区别</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">google guice 框架源码学习</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-04-16T00:00:00.000Z" itemprop="datePublished">April 16, 2022</time> · <!-- -->16 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><a href="https://shanjiancaofu.com" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_o0gy" src="https://shanjiancaofu.com/img/avtor.png" alt="jeesk"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://shanjiancaofu.com" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">jeesk</span></a></div><small class="avatar__subtitle" itemprop="description">java engineer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_mojV" id="1-google-guice-框架简介">1. Google Guice 框架简介<a class="hash-link" href="#1-google-guice-框架简介" title="Direct link to heading">​</a></h2><blockquote><p>​	本文有大量的截图和解释， 不妨用idea边调试边看文章。 </p></blockquote><p>​	在学习 <code>Spring</code> 的时候， 我们常常习惯用 <code>@Bean</code> 将Bean的创建交给spirng 来管理， 使用 <code>@Autowire</code> 实现依赖自动注入Bean。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MyBean{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> public Person person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return new Person();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ABCService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Person Person;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>​		在Spring 的项目中可以随便使用， 在没有Spring 的项目使用 DI 和IOC ，要引入 <code>spring-core</code> , 显得不是那么友好，一些不想用spring 框架的公司就会造出一些轮子，比如Google 公司出了一款轻量的IOC 框架， 下面我们来研究研究。</p><p>本文源码将会使用 google juice 的第一个版本版本号为：<code>66b415a2066cac9f36ed58070777de388f63a3a4 </code>，这个版本大约在20个类左右，基于jdk 1.5的，这个版本代码相对来说非常少。  下面我们带着目的去研究代码。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="2-如何bean创建和管理">2. 如何Bean创建和管理<a class="hash-link" href="#2-如何bean创建和管理" title="Direct link to heading">​</a></h2><p>下面是guice框架将Bar接口和实现类BarImpl绑定的代码，并且获取Bar类型的实例对象。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  public void testManageBean(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ContainerBuilder builder = new ContainerBuilder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    builder.factory(Bar.class, BarImpl.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Container container = builder.create(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Bar instance = container.getInstance(Bar.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(instance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>​	    首先创建了一个容器Builder， 再将Bar 和BarImpl 放入factory 方法中， 再调用create() 创建出容器， 最后通过getInstance() 方法来获取实例。下面看框架代码是如何实现的。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="1--创建containerbuilder">1.  创建ContainerBuilder<a class="hash-link" href="#1--创建containerbuilder" title="Direct link to heading">​</a></h3><p><code>ContainerBuilder builder = new ContainerBuilder();</code></p><p>首先看看注释</p><div class="codeBlockContainer_I0IT language-english theme-code-block"><div class="codeBlockContent_wNvx english"><pre tabindex="0" class="prism-code language-english codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Builds a dependency injection {@link Container}. The combination of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> dependency type and name uniquely identifies a dependency mapping; you can</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use the same name for two different types. Not safe for concurrent use.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>构建一个依赖注入， 依赖的类型和唯一的名字作为映射，两个不同的类型可以使用同一个名字（好像spring 不可以这样）， 这个类并发不安全。</p><p>这里说一下ContainerBuilder 里面的三个变量， 后面会用到。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  final Map&lt;Key&lt;?&gt;, InternalFactory&lt;?&gt;&gt; factories =   new HashMap&lt;Key&lt;?&gt;, InternalFactory&lt;?&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  final List&lt;InternalFactory&lt;?&gt;&gt; singletonFactories = new ArrayList&lt;InternalFactory&lt;?&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  final List&lt;Class&lt;?&gt;&gt; staticInjections = new ArrayList&lt;Class&lt;?&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  boolean created;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol><li>factories             接口类型和实例工厂的映射</li><li>singletonFactories    单例bean的工厂， 所有生命周期是单例的都会加入这个集合</li><li>staticInjections  需要静态注入的Class 类集合</li><li>created               表示该容器是否已经创建，因为容器是是非线程安全，所以用这个字段标记一下</li></ol><p>下面开启idea debug 模式走起。</p><ol><li><p>builder.factory(Bar.class, BarImpl.class);</p><p><img alt="image-20220416135734557" src="/assets/images/image-20220416135734557-a8603f88b6a3b4df5a57b5b82c203523.png" width="519" height="160"></p><ol><li>​																				图1</li></ol></li></ol><p><img alt="image-20220416135800301" src="/assets/images/image-20220416135800301-ff1beae098f05d172336842e4587ec95.png" width="622" height="271"></p><p>​																										图2</p><p><img alt="image-20220416135815906" src="/assets/images/image-20220416135815906-d6031973bdaadb15738008745097cc5b.png" width="691" height="187"></p><p>​																										图3</p><p>从代码发现了方法再次重载， 同时给容器设置了一个默认的名字。 下面再进factory() 方法里面看</p><p><img alt="image-20220416140009260" src="/assets/images/image-20220416140009260-3e98542731f7544e9f2689d64362329b.png" width="1081" height="635"></p><p>​																								图4</p><p>201行的代码生成了一个工厂类， 这个工厂类通过构造器创建一个实例。同时实现类放到了implementation  字段里面了。 再继续debug</p><p><img alt="image-20220416140517464" src="/assets/images/image-20220416140517464-52ea682564c80056cc09af84ed975889.png" width="736" height="542"></p><p>​																					图5</p><p>第92 行把key和对应的生命周期工厂类放入了一个被封装后的工厂，这里为什么会用scope 来封装一下呢？ 主要是因为不同的生命周期有不同的创建方式。 比如单例只需要创建一次即可。从下图的代码的47行中可以看到Singleton 的 scopeFactory  方法加了锁， 这是保证单例安全。</p><p><img alt="image-20220416140847252" src="/assets/images/image-20220416140847252-5bf495580dd16f62f196f6c4d524bb06.png" width="1080" height="469"></p><p>​																							图6</p><p>默认工厂，直接返回工厂就行。</p><p><img alt="image-20220416140923405" src="/assets/images/image-20220416140923405-34d1b5451651b12539590b5f5cc6004a.png" width="766" height="193"></p><p>​																						图7</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-创建容器">2. 创建容器<a class="hash-link" href="#2-创建容器" title="Direct link to heading">​</a></h3><p><code>builder.create(false)</code></p><p><img alt="image-20220416142457081" src="/assets/images/image-20220416142457081-f9d5dcafdf6a5175183a3ef193f114e2.png" width="844" height="458"></p><p>​																									图8</p><ol><li>ensureNotCreated 因为Builder不是线程安全的，所以先确保不会被创建。将factoryies  放入ContainerImpl 里面， 因为loadSingletons是false， 同时我们也没有静态字段(这两行代码先不关注，后面会说）。所以直接将容器返回。</li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="3获取实例">3.	获取实例<a class="hash-link" href="#3获取实例" title="Direct link to heading">​</a></h3><p><code>Bar instance = container.getInstance(Bar.class);</code></p><p><img alt="image-20220416143220942" src="/assets/images/image-20220416143220942-78b941a282a49a7b18490ac8347ae393.png" width="802" height="850"></p><p>​																			图9</p><p>​						callable.call(reference<!-- -->[0]<!-- -->) 回调了487行的getInstance(type, context)， 再继续深入</p><p>​			<img alt="image-20220416143523366" src="/assets/images/image-20220416143523366-cd391b7ddfbec393971b8454d831eebc.png" width="912" height="500"></p><p>​																						图10</p><p>447 行代码使用Bar的Class类型和名字创建了个Key类型实例， 通过key对象去factories 对象里面拿到对应的工厂类， 再创建Bar实现的实例。 毫无疑问下面又会调用创建实例的create方法。</p><p><img alt="image-20220416143746681" src="/assets/images/image-20220416143746681-f5c2536580446dfd74767d8d2008c6ca.png" width="1361" height="404"></p><p>​																					图11</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="4--小结">4.  小结<a class="hash-link" href="#4--小结" title="Direct link to heading">​</a></h3><p>​		guice将接口的类型，名字等生成一个key， 然后生成该接口实现类的工厂类， 同时将Key和工厂类实例放入map里面， 再将map放入容器类里面。当Containner.getInsance() 获取实例的时候， 首先通过接口类型和名字生成key， 去Map 里面去找到对应的实现类的工厂类， 再调用create 方法生成对应的实现类。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="3-依赖注入如何实现">3. 依赖注入如何实现<a class="hash-link" href="#3-依赖注入如何实现" title="Direct link to heading">​</a></h2><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">   public void testInjection() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Container container = createFooContainer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Foo foo = container.inject(Foo.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static class Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject Bar bar;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject Bar copy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject(&quot;s&quot;) String s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject(&quot;i&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void setI(int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.i = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Container createFooContainer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ContainerBuilder builder = new ContainerBuilder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .factory(Bar.class, BarImpl.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .factory(Tee.class, TeeImpl.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 指定字段s,i 注入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .constant(&quot;s&quot;, &quot;test&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      .constant(&quot;i&quot;, 5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return builder.create(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>名字叫Foo的类里面的bar 和copy 和s， 还有字段i， 都是使用了@Inject 注解的， 说明这些字段都是需要注入的。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="1首先创建对象">1.	首先创建对象<a class="hash-link" href="#1首先创建对象" title="Direct link to heading">​</a></h3><ol><li><p>Foo foo = container.inject(Foo.class);</p><p><img alt="image-20220416145409582" src="/assets/images/image-20220416145409582-6539ee11d5fd87128d7488a10fddf06d.png" width="553" height="217"></p><p>​																						图12</p></li></ol><p><img alt="image-20220416145540216" src="/assets/images/image-20220416145540216-4b555a60a75d70b291bb97b6477ba58a.png" width="627" height="401"></p><p>​																								图13</p><p><img alt="image-20220416150031356" src="/assets/images/image-20220416150031356-7f7deaed1909e263e76d93f5e338dff2.png" width="807" height="219"></p><p>​																				图14</p><p>我们发现， 最后其实在调用472行中inject 方法。 继续debug 看看inject 方法到底在干什么。</p><p><img alt="image-20220416150225452" src="/assets/images/image-20220416150225452-3face804fcda338b5d7c2416f349427e.png" width="837" height="295"></p><p>​													图15</p><p>getConstructor(implementation) ， 拿到构造器调用construct 创建对象。 继续向下面看</p><p><img alt="image-20220416150619122" src="/assets/images/image-20220416150619122-02f1b39ed003d2a32c67c110fcfbb50d.png" width="964" height="818"></p><p>​																								图16(请忽略图里说的创建代理对象，这是创建构造器对象)</p><p>为Foo创建对象，并且将创建对象设置到代理中（这里代理用不上，后面在解决循环依赖的时候会说），并且拿到了该类的注入器对象injectors (在373行）， 这个注入器对象从哪儿来的？ 为什么我们debug 没有出来？ 这里其实在</p><p>图15的433 行代码中的  <code>ConstructorInjector constructor = getConstructor(implementation); </code>  ， 调用父类的异步方法去获取注入器。 框架里面有个类是 ReferenceCache， 用来做缓存的， 里面很多的异步操作。 但是今天我们不研究这个， 所以直接略过。</p><p><img alt="image-20220416151157660" src="/assets/images/image-20220416151157660-cc758dc8e12e3213a29478e49914e450.png" width="819" height="695"></p><p>​																							图17</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2注入字段">2.	注入字段<a class="hash-link" href="#2注入字段" title="Direct link to heading">​</a></h3><p>通过构造器的去拿到injects 对象集合, 刚好是4个， 回想一下Foo 里面的字段和静态方法也是4个。我们继续 debug <code> injector.inject(context, t)</code></p><p><img alt="image-20220416152821637" src="/assets/images/image-20220416152821637-5f79230262b70050b77e68ced0c0ef0e.png" width="671" height="479"></p><p>​																							图18</p><p>如图18 所示， 通过反射将字段注入进去。 这就是框架注入的步骤。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="3小结">3.	小结<a class="hash-link" href="#3小结" title="Direct link to heading">​</a></h3><ol><li>创建代理对象</li><li>通过@Inject 获取注入器，使用反射注入对应的字段</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="4-处理依赖循环">4. 处理依赖循环<a class="hash-link" href="#4-处理依赖循环" title="Direct link to heading">​</a></h2><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  @Scoped(SINGLETON)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static class AImpl implements A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final B b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject public AImpl(B b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.b = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public B getB() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  interface B {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    A getA();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static class BImpl implements B {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final A a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject public BImpl(A a) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.a = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public A getA() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="1先创建aimpl的构造器">1.	先创建AImpl的构造器<a class="hash-link" href="#1先创建aimpl的构造器" title="Direct link to heading">​</a></h4><p>AImpl 和 BImpl 相互依赖，并且AImpl是单例， 这种情况下， 框架是如何处理循环依赖的呢。</p><p><img alt="image-20220416155136101" src="/assets/images/image-20220416155136101-958b8f7cd0f3cec43e30fed071b6f168.png" width="1552" height="587"></p><p>​																		图19</p><p><img alt="image-20220416155237541" src="/assets/images/image-20220416155237541-b5435c44c72b355d9a0896668b9f4e29.png" width="1161" height="284"></p><p>​																				图20</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="2当发现自己的构造器参数里面有其它参数时先创建参数对象">2.	当发现自己的构造器参数里面有其它参数时，先创建参数对象<a class="hash-link" href="#2当发现自己的构造器参数里面有其它参数时先创建参数对象" title="Direct link to heading">​</a></h4><p>先Inject 参数B，相当于创建B</p><p><img alt="image-20220416155430941" src="/assets/images/image-20220416155430941-be102310320749c973712f5db41beb4a.png" width="1620" height="226"></p><p><img alt="image-20220416155548515" src="/assets/images/image-20220416155548515-df20c1aecfa29ad92ce68981dc0204e5.png" width="1553" height="890"></p><p><img alt="image-20220416155616081" src="/assets/images/image-20220416155616081-d5b75fa91df8107be933da29cc1043eb.png" width="1643" height="277"></p><p>​																									图21</p><p>进入B的参数构造器， 这个时候B的构造器参数里面需要AImpl的实例对象，</p><p><img alt="image-20220416155723093" src="/assets/images/image-20220416155723093-7f8bc7320e5560e8407d54d70aceb7de.png" width="1409" height="407"></p><p>​																					图22</p><p>​																		又去创建AImpl的单例对象。</p><p><img alt="image-20220416160838526" src="/assets/images/image-20220416160838526-9288d3737dae8afa2d2834b3996c86f5.png" width="1466" height="204"></p><p>​																						图23</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="3-参数对象创建完成后-再创建aimpl实例对象同时将持有aimpl的代理对象重新设置为新的aimpl的实例对象">3. 参数对象创建完成后, 再创建AImpl实例对象，同时将持有AImpl的代理对象重新设置为新的Aimpl的实例对象<a class="hash-link" href="#3-参数对象创建完成后-再创建aimpl实例对象同时将持有aimpl的代理对象重新设置为新的aimpl的实例对象" title="Direct link to heading">​</a></h4><p>判断A的构造器已经构造好了， 就会为B对象的AImpl创建代理对象。 就是下面的方法。 这个时候B持有的其实是AImpl的代理对象。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">if (constructionContext.isConstructing()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // TODO (crazybob): if we can&#x27;t proxy this object, can we proxy the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // other object?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return constructionContext.createProxy(expectedType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>因为在第一次创建Aimpl的时候，已经 赋值了 this.constructing = true。 下次在创建的时候如果是在一个上下文中。下面的代码图21的357 调用的。</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  void startConstruction() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.constructing = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>现在B的Aimpl的代理对象创建好了，B的对象也创建好了。那么就要继续创建AImpl的实例对象。</p><p><img alt="image-20220416160217777" src="/assets/images/image-20220416160217777-a0cb8909d77f2bb119834a173393a4f8.png" width="1571" height="704"></p><p>​																						图24</p><p>创建完AImpl的对象之后， 再将AImpl的真实对象， B持有的InvocationHanlder.setDelegate(真实对象) 即可。 是不是很妙 ？  哎， 不得不佩服大神在2006 年就能写出这种代码， 太厉害啦。  guice框架里面解决依赖循环的是 ConstructionContext 这个类。大家有时间可以看看怎么解决的。 无论AImpl里面有多少个持有A对象实例的字段， 只要AImpl完成实例对象初始化后， 再设置给持有AImpl对象的代理就可以了。</p><p>下面再看看ConstructionContext 的部分代码</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Object createProxy(Class&lt;? super T&gt; expectedType) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TODO: if I create a proxy which implements all the interfaces of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // the implementation type, I&#x27;ll be able to get away with one proxy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // instance (as opposed to one per caller).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!expectedType.isInterface()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw new DependencyException(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          expectedType.getName() + &quot; is not an interface.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (invocationHandlers == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      invocationHandlers = new ArrayList&lt;DelegatingInvocationHandler&lt;T&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DelegatingInvocationHandler&lt;T&gt; invocationHandler =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new DelegatingInvocationHandler&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    invocationHandlers.add(invocationHandler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Proxy.newProxyInstance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      expectedType.getClassLoader(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      new Class[] { expectedType },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      invocationHandler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  void setProxyDelegates(T delegate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (invocationHandlers != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (DelegatingInvocationHandler&lt;T&gt; invocationHandler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          : invocationHandlers) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        invocationHandler.setDelegate(delegate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ul><li><p>createProxy</p><p>创建代理对象， 当创建B对象的时候，在创建构造器的时候会先创建AImpl对象 ， 但是AImpl实例构造器已经被标记， 那就创建一个代理对象。</p></li><li><p>setProxyDelegates</p><p>当B的对象创建完成后，又返回到AImpl创建构造器对象代码的地方，继续创建AImpl对象的实例， 再调用setProxyDelegates 方法，给B持有的Aimpl的代理对象中的delegate设置为AImpl的实例。</p></li></ul><h4 class="anchor anchorWithStickyNavbar_mojV" id="4-小结">4. 小结<a class="hash-link" href="#4-小结" title="Direct link to heading">​</a></h4><p>在两个A，B 两个对象相互依赖的时候， 首先创建A的构造器，标记一下A的构造器已经创建，当发现自己的构造器有参数B的时候先去常见构造器参数B，如果构造器中参数B， 创建实例对象B的时候发现需要创建A对象，这个时候A的构造器已经标记创建了， 那么就给B设置一个代理对象。当B创建完成后， 再创建A的实例对象， 同时再将A的实例对象设置给B的持有的A类型的代理对象。 这个主要是通过proxy 去实现的。 </p><h2 class="anchor anchorWithStickyNavbar_mojV" id="5-静态注入">5. 静态注入<a class="hash-link" href="#5-静态注入" title="Direct link to heading">​</a></h2><p>  现在我们来看看静态注入是如何实现的。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public class StaticInjectionTest extends TestCase {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void testInjectStatics() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Container c = new ContainerBuilder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .constant(&quot;s&quot;, &quot;test&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .constant(&quot;i&quot;, 5)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .injectStatics(StaticInjectionTest.Static.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .create(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(&quot;test&quot;, StaticInjectionTest.Static.s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assertEquals(5, StaticInjectionTest.Static.i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static class Static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject(&quot;i&quot;) static int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static String s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Inject(&quot;s&quot;) static void setS(String s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      StaticInjectionTest.Static.s = s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ol><li><p>直接看 <code>injectStatics</code> 方法调用，首先将需要注入的静态类设置加入集合。</p><p>injectStatics(StaticInjectionTest.Static.class)</p><p><img alt="image-20220416163728265" src="/assets/images/image-20220416163728265-a1e4081b543b1adb34bf1055d334ccd0.png" width="798" height="170"></p></li><li><p>在图5的时候， 我们已经知道在创建容器时会执行静态注入。如下图所示</p></li></ol><p><img alt="image-20220416163912290" src="/assets/images/image-20220416163912290-0033ab33d5870b7ad2c9930b5a6c6426.png" width="993" height="412"></p><p>​		我们继续看执行静态注入的具体流程， 继续debug  <code>container.injectStatics(staticInjections)</code></p><p><img alt="image-20220416164023068" src="/assets/images/image-20220416164023068-eca0ed16528a2336b7dc928fb78167b2.png" width="723" height="434"></p><p>​											下面继续看addInjectorsForMembers 方法做了什么？</p><p><img alt="image-20220416164306372" src="/assets/images/image-20220416164306372-2923cf857da924a2ec50cf229bd5dbe0.png" width="1010" height="398"></p><p>主要是这一段代码，<code>						injectors.add(injectorFactory.create(this, member, inject.value()));</code></p><p>过滤静态字段(inject.value() 是字段的名字，), injector 工厂生成了injector。这里的静态方法同理，所以不截图了。</p><p><img alt="image-20220416165057283" src="/assets/images/image-20220416165057283-295d2cb483e9cdbe9434488634a6103b.png" width="849" height="456"></p><p>​					拿到了注入器后，分别执行MethodInject和FieldInject的inject 方法，下面就不用细说了，背后的原理就是使用反射的方式给字段设置值， 调用静态方法设置值。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="6-guice-和spring-使用di-和ioc-速度对比">6. guice 和spring 使用DI 和IOC 速度对比<a class="hash-link" href="#6-guice-和spring-使用di-和ioc-速度对比" title="Direct link to heading">​</a></h2><p>在java 的生态中有一道永远迈不过的天花板，那就是spring。 所以guice 想和spring 一较高下。 guice 处理bean的速度大约是spring的40倍。这个测试类的名字是  <code>com.google.inject.SpringTest</code>  所有小伙伴们在使用storm 或者flink 之类的框架的时候，该选择guice 就要选择juice 。 </p><h2 class="anchor anchorWithStickyNavbar_mojV" id="7-总结">7. 总结<a class="hash-link" href="#7-总结" title="Direct link to heading">​</a></h2><p>通过本篇文章我们能够学习到</p><ul><li>bean 的创建和管理（IOC)</li><li>依赖注入（DI）是如何实现的</li><li>如何处理依赖循环</li><li>静态注入如何实现</li></ul><p>​			本篇文章只是分析了部分功能的原理，这只是我们学习的一小步，我将在下一篇文章继续深入guice 框架的设计相关的内容， 学习完框架的设计相关的内容， 还会一步一步的手写一个实现简单功能的注入框架。</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_h6_j"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/java/tags/java">java</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/java/tags/di">DI</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/java/tags/ioc">IOC</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/java/java 源码分析"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">java 源码分析</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-google-guice-框架简介" class="table-of-contents__link toc-highlight">1. Google Guice 框架简介</a></li><li><a href="#2-如何bean创建和管理" class="table-of-contents__link toc-highlight">2. 如何Bean创建和管理</a><ul><li><a href="#1--创建containerbuilder" class="table-of-contents__link toc-highlight">1.  创建ContainerBuilder</a></li><li><a href="#2-创建容器" class="table-of-contents__link toc-highlight">2. 创建容器</a></li><li><a href="#3获取实例" class="table-of-contents__link toc-highlight">3.	获取实例</a></li><li><a href="#4--小结" class="table-of-contents__link toc-highlight">4.  小结</a></li></ul></li><li><a href="#3-依赖注入如何实现" class="table-of-contents__link toc-highlight">3. 依赖注入如何实现</a><ul><li><a href="#1首先创建对象" class="table-of-contents__link toc-highlight">1.	首先创建对象</a></li><li><a href="#2注入字段" class="table-of-contents__link toc-highlight">2.	注入字段</a></li><li><a href="#3小结" class="table-of-contents__link toc-highlight">3.	小结</a></li></ul></li><li><a href="#4-处理依赖循环" class="table-of-contents__link toc-highlight">4. 处理依赖循环</a></li><li><a href="#5-静态注入" class="table-of-contents__link toc-highlight">5. 静态注入</a></li><li><a href="#6-guice-和spring-使用di-和ioc-速度对比" class="table-of-contents__link toc-highlight">6. guice 和spring 使用DI 和IOC 速度对比</a></li><li><a href="#7-总结" class="table-of-contents__link toc-highlight">7. 总结</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Repository</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/jeesk" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://gitee.com/jeesk" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Github加速器</div><ul class="footer__items"><li class="footer__item"><a href="https://toolwa.com/github/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>toolwa<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="http://shrill-pond-3e81.hunsh.workers.dev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>hunsh<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 山间草夫, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.e077049a.js"></script>
<script src="/assets/js/main.b2bb5637.js"></script>
</body>
</html>