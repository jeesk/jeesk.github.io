<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://shanjiancaofu.com/data-structure-and-algorithm</id>
    <title>山间草夫的小站 Blog</title>
    <updated>2022-03-09T06:59:09.765Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://shanjiancaofu.com/data-structure-and-algorithm"/>
    <subtitle>山间草夫的小站 Blog</subtitle>
    <icon>https://shanjiancaofu.com/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[图算法解析]]></title>
        <id>/图算法解析</id>
        <link href="https://shanjiancaofu.com/data-structure-and-algorithm/图算法解析"/>
        <updated>2022-03-09T06:59:09.765Z</updated>
        <summary type="html"><![CDATA[图结构和2种搜索算法入门]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="图结构和2种搜索算法入门">图结构和2种搜索算法入门<a class="hash-link" href="#图结构和2种搜索算法入门" title="Direct link to heading">​</a></h2><blockquote><p>​	在数据的逻辑结构D=（KR）中，如果K中结点对于关系R的前趋和后继的个数不加限制，即仅含一种任意的关系，则称这种数据结构为图形结构</p><p>这是百度百科的解释，说人话， 图是一种数据结构，其中结点可以具有零个和多个相邻元素。 两个结点称为边。 结点也可以叫做顶点。 </p></blockquote><p><img alt="image-20220303200106136" src="/assets/images/image-20220303200106136-f99f3ef689fede8d63e818e26674dde9.png" width="505" height="395"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="1-图的概念">1. 图的概念<a class="hash-link" href="#1-图的概念" title="Direct link to heading">​</a></h3><p>1) 顶点(vertex)</p><p>2) 边（edge)</p><p>3) 路径 </p><p>   A路径有:  A -&gt; B -&gt; D,A -&gt; B -&gt; C -&gt; E,   B有路径 B -&gt; D，B -&gt; C -&gt; E</p><p>4) 有向图和无向图(有向图指的是两个元素指两个元素有方向，无向图两个元素没有方向)  比如 A-&gt;B A-&gt;D</p><p>5) 带权图。 指的是这个边的值， 比如 A-&gt; B 的边表示10公里， B -&gt; C的边表示 5公里。</p><p>   <img alt="image-20220303200657735" src="/assets/images/image-20220303200657735-5eaae6f7accd371af1bafca79b48d481.png" width="247" height="219"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-图的表示方式">2. 图的表示方式<a class="hash-link" href="#2-图的表示方式" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="21-邻接矩阵">2.1 邻接矩阵<a class="hash-link" href="#21-邻接矩阵" title="Direct link to heading">​</a></h4><p>邻接矩阵是表示图形中顶点的之间的关系的矩阵，对于n个 顶点的图而言， 矩阵的row和col 表示的是 1...n个点。如下图所示 </p><p><img alt=" " src="/assets/images/image-20220303200908410-02698a156f915ac396e2743d13f43faf.png" width="599" height="257"></p><h3 class="anchor anchorWithStickyNavbar_mojV" id="22-邻接表">2.2 邻接表<a class="hash-link" href="#22-邻接表" title="Direct link to heading">​</a></h3><ol><li><p>邻接矩阵需要为第个顶点都分配n个边的空间， 其实有很多的边不存在，造成空间浪费</p></li><li><p>邻接表只关心边， 不关心不存在的边。 所以没有空间浪费， 邻接表由数组 + 链表组成 </p><p><img alt="image-20220303201115950" src="/assets/images/image-20220303201115950-70d1a4d30910cbdbc6091177b2bbdcd7.png" width="1040" height="271"></p></li></ol><h3 class="anchor anchorWithStickyNavbar_mojV" id="3-图索算法">3. 图索算法<a class="hash-link" href="#3-图索算法" title="Direct link to heading">​</a></h3><blockquote><p> 图搜索算法有深度优先(dfs)，和广度优先(bfs)两种。</p><p><img alt="image-20220303201411405" src="/assets/images/image-20220303201411405-cb6022d39ce2aa736ee19c8fee49dd4a.png" width="615" height="355"></p><p>如果从1 这个节点为起始点来遍历， 深度优先，和广度的顺序不相同。 </p><p> 深度优先搜索: 1 ，2，4，8，5，3，6，7</p><p> 广度优先搜索： 1，2，3，4，5，6，7，8</p><p> 由上面的遍历顺序我们可以发现深度是纵向遍历，而广度是横向遍历。</p><p>下面我们将编写两种算法和分析2种算法的具体执行流程。</p></blockquote><h4 class="anchor anchorWithStickyNavbar_mojV" id="31-使用代码实现邻接矩阵和邻接表">3.1 使用代码实现邻接矩阵和邻接表<a class="hash-link" href="#31-使用代码实现邻接矩阵和邻接表" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_mojV" id="311-邻接表的实现">3.1.1 邻接表的实现<a class="hash-link" href="#311-邻接表的实现" title="Direct link to heading">​</a></h5><p>这里暂时先留下， 后面填坑</p><h5 class="anchor anchorWithStickyNavbar_mojV" id="312-邻接矩阵">3.1.2 邻接矩阵<a class="hash-link" href="#312-邻接矩阵" title="Direct link to heading">​</a></h5><p>下图是一个 邻接矩阵， 通过下面数据可以看到有以下关系</p><p>A - B , B - C, C-D 有连接关系， 下面的图也可以用数据结构2维数组来表示, 我们这里规定两个节点相交的时候值为1</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">int[][] = new int[4][4];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">那么A - B ,在数组中表示为int[0][1] = 1,int[1][0] = 1.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">那么B - C ,在数组中表示为int[0][1] = 1,int[1][0] = 1.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">那么C - D ,在数组中表示为int[0][1] = 1,int[1][0] = 1.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img alt="image-20220304125146917" src="data:image/png;base64,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" width="1169" height="349"></p><p>代码如下</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">    public static class Graph {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 顶点数据(vertex)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private List&lt;String&gt; vertexts;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 边(节点相交数据)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int[][] edges;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 边的数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int numberOfEdges;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Graph(int count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            vertexts = new ArrayList&lt;&gt;(count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            edges = new int[count][count];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            isVeisited = new boolean[count];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 插入顶点的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param vertex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void addVertex(String vertex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            vertexts.add(vertex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String getVertext(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return vertexts.get(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param v1 第一个节点的索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param v2 第干个节点的索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param weight 权重（这里我们规定加入两个相交权重为1）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void insertEdge(int v1, int v2, int weight) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            edges[v1][v2] = weight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            edges[v2][v1] = weight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numberOfEdges++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void insertEdge(int v1, int v2, int weight) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            edges[v1][v2] = weight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            edges[v2][v1] = weight;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numberOfEdges++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void showGrpah() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int[] edge : edges) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(Arrays.toString(edge));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String getValueByIndex(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return vertexts.get(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>下面来测试一下代码, 假设有4个顶点分别是 数据分别为1，2，3，4，5，6，7，8 他们的索引分别是 0, 1,2,3 ,4，5，6，7，8 </p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public class GraphDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 插入8个顶点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String[] Vertexs = {"1", "2", "3", "4", "5", "6", "7", "8"};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Graph graph = new Graph(Vertexs.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String s : Vertexs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            graph.addVertex(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 插入8条边， </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(0, 1, 1); // 这里的第一个参数0表示顶点1的索引，第二个参数表示数据为2的顶点的索引，第三个参数表示两个顶点相交。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(0, 2, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(1, 3, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(1, 4, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(3, 7, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(4, 7, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(2, 5, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(2, 6, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.insertEdge(5, 6, 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 打印出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        graph.showGrpah();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>运行上面的main方法，控制台打印出信息如下</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">[0, 1, 1, 0, 0, 0, 0, 0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[1, 0, 0, 1, 1, 0, 0, 0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[1, 0, 0, 0, 0, 1, 1, 0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[0, 1, 0, 0, 0, 0, 0, 1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[0, 1, 0, 0, 0, 0, 0, 1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[0, 0, 1, 0, 0, 0, 1, 0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[0, 0, 1, 0, 0, 1, 0, 0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[0, 0, 0, 1, 1, 0, 0, 0]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>通过上面的例子可以得到发现数据为1 的这个顶点的路径是 1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7 ， 或者也有1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8 ， 因为顶点相交是多对多，路径远远不止上面2条。 于是就有了下面的2种算法来求出路径。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="32-深度优先搜索depth-first-search">3.2 深度优先搜索(Depth First Search)<a class="hash-link" href="#32-深度优先搜索depth-first-search" title="Direct link to heading">​</a></h4><p>在讲步骤之前先讲两个概念，</p><p>3.2.1  顶点的第一个邻接点 </p><p>第一个是根据索引拿到该索引的第一个邻接点(索引)， 比如在上面 3.1.2中的数据为1的索引的为0， 那么他的第一个邻接点就为1. </p><p><img alt="image-20220304132244427" src="/assets/images/image-20220304132244427-3ee6a27210d755bf6155074677091f55.png" width="871" height="328"></p><p>代码如下</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 得到该索引的第一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param index</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int getFirtNeighbor(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; vertexts.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (edges[index][i] &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>3.2.2  根据前一个邻接点的来获取下一个邻接点的索引</p><p>![image-20220304132856641]<!-- -->(图算法解析.assets/image-20220304132856641.png代码如下</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 根据前一个邻节点来获取下一个邻节点的坐标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param v1 第一个接点的索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param v2 第一个接点的领节点索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int getNextNeighbor(int v1, int v2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = v2 + 1; i &lt; vertexts.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (edges[v1][i] &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="33-广度优先搜索breadth-first-search">3.3 广度优先搜索(Breadth First Search)<a class="hash-link" href="#33-广度优先搜索breadth-first-search" title="Direct link to heading">​</a></h4>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sort]]></title>
        <id>/Sort</id>
        <link href="https://shanjiancaofu.com/data-structure-and-algorithm/Sort"/>
        <updated>2022-02-12T02:46:52.916Z</updated>
        <summary type="html"><![CDATA[冒泡，交换，选择， 插入]]></summary>
        <content type="html"><![CDATA[<h4></h4><p>冒泡，交换，选择， 插入</p><p>基数排序</p><p>shell
快速
归并
堆排序</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[八皇后问题解决方案详解]]></title>
        <id>queue-8</id>
        <link href="https://shanjiancaofu.com/data-structure-and-algorithm/queue-8"/>
        <updated>2022-02-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[八皇后问题的程序解答]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="八皇后问题的程序解答">八皇后问题的程序解答<a class="hash-link" href="#八皇后问题的程序解答" title="Direct link to heading">​</a></h2><blockquote><p>在8×8格的<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B/80888" target="_blank" rel="noopener noreferrer">国际象棋</a>上摆放8个<a href="https://baike.baidu.com/item/%E7%9A%87%E5%90%8E/15860305" target="_blank" rel="noopener noreferrer">皇后</a>，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF/24098" target="_blank" rel="noopener noreferrer">高斯</a>认为有76种方案。1854年在<a href="https://baike.baidu.com/item/%E6%9F%8F%E6%9E%97/75855" target="_blank" rel="noopener noreferrer">柏林</a>的象棋杂志上不同的作者发表了40种不同的解，后来有人用<a href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" target="_blank" rel="noopener noreferrer">图论</a>的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338" target="_blank" rel="noopener noreferrer">计算机</a>发明后，有多种计算机语言可以编程解决此问题。</p></blockquote><p>由上面的概述可以得出, 任意两个皇后不能处于同一行,同一列, 或者同一斜线.  这条规则是校验八皇后是否合法的规则, 后面的代码将根据这条规则来编写. </p><h3 class="anchor anchorWithStickyNavbar_mojV" id="1-回溯法">1. 回溯法<a class="hash-link" href="#1-回溯法" title="Direct link to heading">​</a></h3><blockquote><p>​	首先我们定义一个数组 array = {0 , 4, 7, 5, 2, 6, 1, 3},用单数组表示八皇后的位置, </p><p>上面的数组依次表示8皇后在棋盘的位置, array <!-- -->[0]<!-- --> = 0, array <!-- -->[1]<!-- -->=4, array<!-- -->[index]<!-- --> = val ,可以得出每个八皇后的位置在第index+1行, </p><p>在(val+1) 列, 入下图所示, 可以看到下面的表格是满足任意两个皇后不能处于同一行,同一列, 或者同一斜线.</p></blockquote><table><thead><tr><th align="center">1</th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">3</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">4</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center">5</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">6</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">7</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">8</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 class="anchor anchorWithStickyNavbar_mojV" id="11-八皇后的规则校验">1.1 八皇后的规则校验<a class="hash-link" href="#11-八皇后的规则校验" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 校验该皇后是否和前面的皇后冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param index 第几个皇后(index表示在数组的索引)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return 该皇后的位置是否冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isJudge(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果是在数组的第一个皇后直接返回不冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历该皇后前面的皇后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; index; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 1. 判断该皇后是否和前面的皇后在同一列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (array[index] == array[i]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 假如array[0] = 0, array[1]=1, array[2] = 1那么这个就是冲突的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 2. 判断该皇后是否和其他的皇后在同一条斜线</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // array = {0,1,2,3,4,5,6,7} , 这8个皇后在同一条斜线, 由此可以得到, 他们的差值相等的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  第一个皇后在第一行第一列, 第二个皇后在第二行第二列, 第三个皇后在第三行第三列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  由此可得第n个皇后和n-个皇后的位置(index)的差值,等于他们所在y轴(val)的差值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Math.abs(array[index] - array[i]) == Math.abs(index - i)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 3. 判断是否在同一行由于我们已经规定好了 array = {0 , 4, 7, 5, 2, 6, 1, 3},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    每一个皇后的位置的行在 array[index] =val, 由index 决定,所以肯定不在同一行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="12-放入皇后">1.2 放入皇后<a class="hash-link" href="#12-放入皇后" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param index 皇后在数组的位置(index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void putQueue(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index == max) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当index = max的时候, 表示皇后已经放了8个, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            num++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printQueue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; max; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将皇后放入数组, 这里的i代表皇后在棋盘的列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            array[index] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (isJudge(index)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 不冲突, 继续放入皇后到数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                putQueue(index + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 冲突的话, 继续循环放入新的皇后到数组(改变当前皇后的列)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="13-完整代码如下">1.3 完整代码如下<a class="hash-link" href="#13-完整代码如下" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Queue8Demo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //定义一个max表示共有多少个皇后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int max = 8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //定义数组array, 保存皇后放置位置的结果,比如 arr = {0 , 4, 7, 5, 2, 6, 1, 3}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] array = new int[max];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 解法计数器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int num = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long startTime = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Queue8Demo queue8 = new Queue8Demo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        queue8.putQueue(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println("耗时:" + (System.currentTimeMillis() - startTime));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 校验该皇后是否和前面的皇后冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param index 第几个皇后(index表示在数组的索引)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return 该皇后的位置是否冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isJudge(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果是在数组的第一个皇后直接返回不冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历该皇后前面的皇后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; index; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 1. 判断该皇后是否和前面的皇后在同一列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (array[index] == array[i]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 假如array[0] = 0, array[1]=1, array[2] = 1那么这个就是冲突的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 2. 判断该皇后是否和其他的皇后在同一条斜线</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // array = {0,1,2,3,4,5,6,7} , 这8个皇后在同一条斜线, 由此可以得到, 他们的差值相等的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  第一个皇后在第一行第一列, 第二个皇后在第二行第二列, 第三个皇后在第三行第三列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  由此可得第n个皇后和n-个皇后的位置(index)的差值,等于他们所在y轴(val)的差值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Math.abs(array[index] - array[i]) == Math.abs(index - i)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 3. 判断是否在同一行由于我们已经规定好了 array = {0 , 4, 7, 5, 2, 6, 1, 3},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    每一个皇后的位置的行在 array[index] =val, 由index 决定,所以肯定不在同一行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 放入皇后到数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param index 皇后在数组的位置(index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void putQueue(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index == max) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当index = max的时候, 表示皇后已经放了8个,已经得到一种解法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            num++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printQueue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; max; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将皇后放入数组, 这里的i代表皇后在棋盘的列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            array[index] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (isJudge(index)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 不冲突, 继续放入皇后到数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                putQueue(index + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 冲突的话, 继续循环放入新的皇后到数组(改变当前皇后的列)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void printQueue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print("解法" + num + ":");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; array.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print(array[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4></h4><h2 class="anchor anchorWithStickyNavbar_mojV" id="总结">总结<a class="hash-link" href="#总结" title="Direct link to heading">​</a></h2><ol><li>通过递归解决了八皇后的解法, 学习递归的用法</li></ol>]]></content>
        <author>
            <name>jeesk</name>
            <uri>https://shanjiancaofu.com</uri>
        </author>
        <category label="algorithm" term="algorithm"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[约瑟夫问题详细解法]]></title>
        <id>josephu-question</id>
        <link href="https://shanjiancaofu.com/data-structure-and-algorithm/josephu-question"/>
        <updated>2022-01-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[约瑟夫问题的几种算法]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="约瑟夫问题的几种算法">约瑟夫问题的几种算法<a class="hash-link" href="#约瑟夫问题的几种算法" title="Direct link to heading">​</a></h2><blockquote><p>据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决。Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏</p></blockquote><p>现在简单的举个例子:</p><p>假如一共有8个, 从第一个开始报数, 然后每次报3个人出圈</p><p>1,2,3,4,5,6,7,8</p><ol><li>1,2,3,4,5,6,7,8      3号出圈</li><li>1,2,4,5,6,7,8         6号出圈</li><li>1,2,4,5,7,8            1号出圈</li><li>2,4,5,7,8               5号出圈</li><li>2,4,7,8                 2号出圈</li><li>4,7,8                    8号出圈</li><li>4,7                       4号出圈</li><li>​     7                         </li></ol><p>现在大家应该是明白了, 约瑟夫算法的玩法, 那么下面分享几种不同思路的解法</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="1-环形链表解法">1. 环形链表解法<a class="hash-link" href="#1-环形链表解法" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="11思路分析">1.1	思路分析<a class="hash-link" href="#11思路分析" title="Direct link to heading">​</a></h4><ol><li>首先是拿到环形链表的第一个数据first , 和最后一个数据last</li><li>在报数的时候,  循环报数,  每次first 和last 移动(m-1)次, 然后删除当前节点, 相当于出圈</li><li>当过first= last的时候, 只有最后一个人了</li></ol><h4 class="anchor anchorWithStickyNavbar_mojV" id="12-代码实战">1.2 代码实战<a class="hash-link" href="#12-代码实战" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">package com.shanjiancaofu;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class JosephuQuestion {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LinkedCircle linkedCircle = new LinkedCircle();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 增加8个人, 计算出圈的人</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        linkedCircle.addEle(8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        linkedCircle.calu(1, 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class LinkedCircle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param startNo  从第几个人开始数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param countNum 报数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void calu(int startNo, int countNum) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 找到最后一个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Element lastEle = first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (lastEle.getNext() == first) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastEle = lastEle.getNext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将lastEle和first 移动(startNo-1), 这里移动的原因是因为实际情况可能不是从第一个人开始报数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; startNo - 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastEle = lastEle.getNext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                first = first.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 循环报数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (lastEle == first) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 只有一个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 执行报数, 移动first数据,找到出圈的人</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int i = 0; i &lt; countNum - 1; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastEle = lastEle.getNext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    first = first.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 得到的first 就是移除圈的人</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println("移除圈的人NO:" + first.getNo());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                first = first.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lastEle.setNext(first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Element first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 增加几个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param nums 增加的数据个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void addEle(int nums) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nums &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println("参数异常");</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 链表的最后一个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Element lastElement = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 1; i &lt;= nums; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Element element = new Element();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                element.setNo(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (i == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 第一个数据是first, 并且first的next也是first自己</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    first = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    first.setNext(first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastElement = first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 其他的数据next是first,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    element.next = first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 设置上一个数据的next是最后一个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastElement.next = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 并且更新lastElelment为最后一个数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastElement = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public static class Element {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 数据编号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            private int no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 下一个为数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            private Element next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public int getNo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void setNo(int no) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.no = no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Element getNext() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void setNext(Element next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.next = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="13-控制台如下">1.3 控制台如下<a class="hash-link" href="#13-控制台如下" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">移除圈的人NO:3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">移除圈的人NO:6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">移除圈的人NO:1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">移除圈的人NO:5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">移除圈的人NO:2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">移除圈的人NO:8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">移除圈的人NO:4</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div>]]></content>
        <author>
            <name>jeesk</name>
            <uri>https://shanjiancaofu.com</uri>
        </author>
        <category label="algorithm" term="algorithm"/>
    </entry>
</feed>